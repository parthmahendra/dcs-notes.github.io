<!DOCTYPE html>
<html lang=" en-US">

<head>

    
    <meta charset="UTF-8"><!-- Include tocNAV javascript -->
    <script type="text/javascript" src="/assets/js/tocNav.js"></script>

    <!-- seo used to be here -->
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="preload" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700&display=swap" as="style"
        type="text/css" crossorigin>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="/assets/css/style.css">
    <title>CS140 Security & Authentication Protocols</title>
</head>

<body>
    <div id="mainGrid" class="container">
        <header style="padding:10px;" class="page-header notes-header" role="banner">
            <h1 class="project-name">Security & Authentication Protocols</h1>
        </header>
        <div title="Table of Contents" class="buttonCol" onclick="toggleNav()">
            <div class="navArrow">
                <i></i>
            </div>
        </div>
        <div class="navBox">
            <div id="sidenav" class="sideNav closedNav">
                <h2 style="margin-left: 10px;">Table of Contents</h2><ul class="table-of-contents"><li><a href="#diffie-hellman-merkel-key-exchange-protocol">Diffie-Hellman-Merkel Key Exchange Protocol</a></li><li><a href="#authentication-protocol">Authentication Protocol</a><ul><li><a href="#replay-attack">Replay Attack</a></li><li><a href="#mutual-authentication">Mutual Authentication</a></li></ul></li><li><a href="#authentication-spoofing">Authentication Spoofing</a></li><li><a href="#needham-schroeder-secret-key-based-protocol">Needham-Schroeder Secret key-based protocol</a><ul><li><a href="#possible-attack">Possible Attack</a></li></ul></li></ul>
</div>
        </div>
        
        <div class="contents">
            <main id="content" class="main-content" role="main">
                <div class="partNav"><a href="/CS140/secure-email.html" title="Secure Email">ğŸ‘ˆPrev</a><a href="./" title="CS140 Home">ğŸ¡CS140</a><a href="/CS140/part8.html" title="Web Server Security Issues">NextğŸ‘‰</a></div>
                <!-- Main Content of markdown or sub-layouts-->
                <!-- Each module has its own layout to allow module layouts to be customised -->
<!-- The layout name is also used by the notes layout to display the correct module code -->

<p align="center">A security protocol is a fixed pattern of exchanges (steps) between 2 or more communication parties to achieve a security related task.</p>

<h2 id="diffie-hellman-merkel-key-exchange-protocol">Diffie-Hellman-Merkel Key Exchange Protocol</h2>

<p><em>For brevity sake, I will refer to it as DHM</em></p>

<blockquote>
  <p>We use the DHM protocol when two parties wish to <strong>communicate privately</strong>, but the <strong>communication channel is not secure</strong> (everything can be read by outsiders), and they want to use <strong>secret key encryption</strong>.</p>
</blockquote>

<p>To do so, A and B have to first publicly agree on values for y and p in a modular exponentiation one way function: y<sup>x</sup> mod p</p>

<ul>
  <li>y needs to be the primitive root of p</li>
  <li>p is an enormously large prime number</li>
  <li>The two numbers can be publicly known</li>
</ul>

<p>Then A chooses a secret number, <strong><em>a</em></strong> that has to</p>

<ul>
  <li>Put <strong><em>a</em></strong> into the one-way function and computes the result y<sup>a</sup> mod p = <strong><em>v<sub>A</sub></em></strong></li>
  <li>A sends <strong><em>v<sub>A</sub></em></strong> to B and receives a <strong><em>vB</em></strong></li>
  <li>A applies their function to <strong><em>vB</em></strong>: <strong><em>(vB)<sup>a</sup></em></strong> mod p</li>
  <li>B does the same and gets <strong><em>v<sub>b</sub></em></strong> mod p</li>
</ul>

<p>A and B will <strong>arrive at the same value</strong> which they use as their secret key: <strong><em>v<sub>b</sub></em></strong> mod p = <strong><em>(vB)<sup>a</sup></em></strong> mod p</p>

<h2 id="authentication-protocol">Authentication Protocol</h2>

<p>Normally when working in a local environment (secure channel) with a fixed link to the host, we use passwords to authenticate a user. However, more must be done over insecure channels.</p>

<blockquote>
  <p>Either use <strong>encrypted passwords</strong>, <strong>digital signature</strong>, or <strong>public key encryption</strong> for authentication.</p>
</blockquote>

<p>Recall how public keys can be used to ensure integrity and non-repudiation, provided that the public key is trusted. Why canâ€™t it provide authentication as well?</p>

<h3 id="replay-attack">Replay Attack</h3>

<blockquote>
  <p>Letâ€™s say A sends B a message encrypted by KU<sub>A</sub>, B acknowledges that A is in fact A. However E also stores this message but does not touch it. After the communication with A and B is over, E can <strong>replay</strong> the message to B and B would accept E as A.</p>
</blockquote>

<p><strong>Solution 1.</strong> B generates a token R, which is a random number (also called a <em>nonce</em> :eyes: ), that A needs to sign for authentication. The interaction can be formalised with the notation below. The final authenticated token, if encrypted with Aâ€™s private key can only mean it was authenticated by A.</p>

<ol>
  <li>A â€“&gt; B : A</li>
  <li>B â€“&gt; A : R</li>
  <li>A â€“&gt; B : [R]<sub>A</sub></li>
</ol>

<p><strong>Solution 2.</strong> Timestamping. When A sends message to B, they include a timestamp in the encrypted message. If the message is replayed by E, B will know that it is an old message.</p>

<h3 id="mutual-authentication">Mutual Authentication</h3>

<p>Our above examples are a <strong>unilateral authentication</strong>: A authenticates B</p>

<p><strong>Mutual authentication.</strong> Two-way authentication</p>

<ol>
  <li>A â€“&gt; B : A, R<sub>A</sub></li>
  <li>B â€“&gt; A : R<sub>B</sub>, [R<sub>A</sub>]<sub>B</sub> â€“ In this step, A will know that B is truly B (as long as public key verified)</li>
  <li>A â€“&gt; B : [R<sub>B</sub>]<sub>A</sub>       â€“ Here B, will know A is A</li>
</ol>

<h2 id="authentication-spoofing">Authentication Spoofing</h2>

<blockquote>
  <p>Thereâ€™s still a problem with our protocol. A could communicate with E, but E could be malicious and decide to pass on the message to B. Now B will pass the token to E and E passes it to A and then passes the encrypted token back to B from A.</p>

  <p>As a result, B thinks that they are communicating with A.</p>

  <p>This is often referred to as a â€œman-in-the-middleâ€ (MITM) attack</p>
</blockquote>

<p><strong>Solution 1.</strong> Include the identity of the intended recipient encrypted along with the token from the recipient.</p>

<ol>
  <li>A â€“&gt; B: A</li>
  <li>B â€“&gt; A: R</li>
  <li>A â€“&gt; B: [R, E]<sub>A</sub> ğŸ””â•â—</li>
</ol>

<p><strong>Solution 2.</strong> If weâ€™re using encryption for authentication (Needham-Schroeder Authentication protocol), enclose the senderâ€™s ID.</p>

<ol>
  <li>A â€“&gt; B: A</li>
  <li>B â€“&gt; A: {B, R}<sub>KP<sub>A</sub></sub></li>
  <li>A â€“&gt; B: R</li>
</ol>

<blockquote>
  <p>The principle is to include both sender and receiverâ€™s info in the protocol</p>

  <ul>
    <li>When using encryption, senderâ€™s id is included.</li>
    <li>When using digital signature, receiverâ€™s id is included</li>
  </ul>
</blockquote>

<h2 id="needham-schroeder-secret-key-based-protocol">Needham-Schroeder Secret key-based protocol</h2>

<p>We saw the public key encryption protocol by NS, they also proposed a secret key <strong>authentication</strong> protocol. In this protocol, there are 3 parties: A (K<sub>SA</sub> â€“ key given to A by server), B (K<sub>SB</sub> â€“ key given to B by server), Server (K<sub>AB</sub> â€“ session key that server provides to both A and B)</p>

<ol>
  <li>A â†’ S: A, B, R<sub>A1</sub></li>
  <li>S â†’ A: { R<sub>A1</sub>, B, { K<sub>AB</sub>, A }<sub>K<sub>SBÂ </sub></sub>}<sub>K<sub>SA</sub></sub></li>
  <li>A â†’ B: { K<sub>AB</sub>, A }<sub>K<sub>SB</sub></sub>, { R<sub>A2</sub> }<sub>K<sub>AB</sub></sub></li>
  <li>B â†’Â A: { R<sub>A2</sub> â€“ 1, R<sub>B</sub>}<sub>K<sub>AB</sub></sub></li>
  <li>A â†’Â B: { R<sub>B</sub> â€“ 1 }<sub>K<sub>AB</sub></sub></li>
</ol>

<p><img src=".\part7.assets\needhamSchroeder.png" alt="needhamSchroeder" /></p>

<blockquote>
  <p><strong>Disadvantages.</strong> Server needs to distribute secret key directly to B, and since B does not ask for a key, but receives one, if B is not responsive (AFK) or the server somehow canâ€™t reach B then there will be no communication.</p>
</blockquote>

<h3 id="possible-attack">Possible Attack</h3>

<p>If E manages to obtain an old session key, K<sub>AB</sub>, E can replay the old message (step 3) relating to that session key.</p>

<ul>
  <li>If B completes the protocol and assumes that they shared a key with A, E would have tricked B.</li>
  <li>Can prevent this easily with timestamps.</li>
</ul>

                
                <footer class="site-footer">
                    
                    <span class="site-footer-owner"><a href="https://github.com/CSRG-Group/dcs-notes.github.io">dcs-notes.github.io</a> is maintained by <a href="https://github.com/CSRG-Group">CSRG-Group</a>.</span>
                    
                </footer>
            </main>
        </div>
    </div>
</body>

</html>