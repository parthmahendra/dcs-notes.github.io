<!DOCTYPE html>
<html lang=" en-US">

<head>

    
    <meta charset="UTF-8"><script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- Include tocNAV javascript -->
    <script type="text/javascript" src="/assets/js/tocNav.js"></script>

    <!-- seo used to be here -->
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="preload" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700&display=swap" as="style"
        type="text/css" crossorigin>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="/assets/css/style.css">
    <title>CS126 Directed Graphs</title>
</head>

<body>
    <div id="mainGrid" class="container">
        <header style="padding:10px;" class="page-header notes-header" role="banner">
            <h1 class="project-name">Directed Graphs</h1>
        </header>
        <div title="Table of Contents" class="buttonCol" onclick="toggleNav()">
            <div class="navArrow">
                <i></i>
            </div>
        </div>
        <div class="navBox">
            <div id="sidenav" class="sideNav closedNav">
                <h2 style="margin-left: 10px;">Table of Contents</h2><ul class="table-of-contents"><li><a href="#directed-graphs">Directed graphs</a><ul><li><a href="#properties">Properties</a></li><li><a href="#strong-connectivity-algorithm">Strong Connectivity Algorithm</a></li></ul></li><li><a href="#transitive-closure">Transitive closure</a><ul><li><a href="#floyd-warshall-algorithm">Floyd-Warshall Algorithm</a><ul><li><a href="#speed-analysis">Speed Analysis</a></li></ul></li></ul></li><li><a href="#topological-ordering">Topological ordering</a><ul><li><a href="#topological-sorting-with-dfs">Topological Sorting with DFS</a></li></ul></li></ul>
</div>
        </div>
        
        <div class="contents">
            <main id="content" class="main-content" role="main">
                <div class="partNav"><a href="/CS126/part11.html" title="Graphs">üëàPrev</a><a href="./" title="CS126 Home">üè°CS126</a><a href="/CS126/part12.html" title="General Algorithms">Nextüëâ</a></div>
                <!-- Main Content of markdown or sub-layouts-->
                <!-- Each module has its own layout to allow module layouts to be customised -->
<!-- The layout name is also used by the notes layout to display the correct module code -->

<h2 id="directed-graphs">Directed graphs</h2>

<blockquote>
  <p>Directed graphs (digraphs) are graphs where <strong>every edge</strong> is directed. Edge \((a,b)\) goes from \(a\) to \(b\), but not the other way around.</p>

  <p>It can be applied to dependency and scheduling problems. When representing it in concrete implementations, we tend to keep in and out edges separately</p>
</blockquote>

<h3 id="properties">Properties</h3>

<p>If a <strong>simple</strong> directed graph has \(m\) edges and \(n\) vertices, then \(m \leq n \cdot (n-1)\), since every vertex can connect to every other vertex bar itself</p>

<p>There is more terminology specifically about digraphs:</p>

<ul>
  <li>One vertex is said to be <strong>reachable</strong> from the other if there <strong>exists a directed path</strong> from the other to it</li>
  <li>A digraph is said to be <strong>strongly connected</strong> if <strong>each vertex is reachable</strong> from every other vertex</li>
</ul>

<h3 id="strong-connectivity-algorithm">Strong Connectivity Algorithm</h3>

<p>We can identify strong connectivity by running DFS on a chosen vertex \(v\) in \(G\) and \(G‚Äô\), where \(G‚Äô\) is \(G\) but with the directed edges <strong>reversed</strong>.</p>

<ul>
  <li>Firstly, we perform DFS from \(v\) in \(G\). If there is a vertex \(u\) <strong>not visited</strong>, then \(G\) is <strong>not</strong> strongly connected. Otherwise, it shows that there exists a path from \(v\) to every other vertex.</li>
  <li>Next we perform DFS from \(v\) in \(G‚Äô\). Again, if there is a vertex \(u\) not visited it is not strongly connected. Otherwise, it shows that there exists a path from every other vertex to \(v\).</li>
  <li>If both DFS show that there is no such vertex \(u\), then \(G\) is strongly connected.</li>
</ul>

<p>This has a running time of \(O(n+m)\).</p>

<p>It is also possible to create maximal subgraphs with every vertex being reachable in \(O(n+m)\) time, but this is more involved.</p>

<h2 id="transitive-closure">Transitive closure</h2>

<blockquote>
  <p>Given a digraph \(G\), the transitive closure of \(G\) is the digraph \(G^*\) such that</p>

  <ul>
    <li>
      <p>\(G^*\) has the same vertices as \(G\)</p>
    </li>
    <li>
      <p>If \(G\) has a directed path from \(u\) to \(v\), and \(u \neq v\), then \(G^*\) has a directed edge from \(u\) to \(v\)</p>
    </li>
  </ul>

  <p>The transitive closure provides reachability information about a digraph</p>
</blockquote>

<p>Informally, this means that every pair of vertices with a path between them is adjacent</p>

<p><img src=".\images\transitiveClosure.png" alt="transitiveClosure" class="center" style="zoom:50%;" /></p>

<p>Image source: <em>Data Structures and Algorithms in Java, Goodrich, Tamassia, Goldwasser</em></p>

<p>We can naively compute this by performing DFS for each vertex in graph to identify every reachable edge from it, then setting edges between them. However, this is very slow, being \(O(n \cdot (n+m))\) time.</p>

<p>Instead, we can use the <strong>Floyd-Warshall algorithm</strong>, which is a dynamic programming solution</p>

<h3 id="floyd-warshall-algorithm">Floyd-Warshall Algorithm</h3>

<p><img src=".\images\floydWarshall.png" alt="floydWarshall" class="center" /></p>

<p>Image source: <em>Data Structures and Algorithms in Java, Goodrich, Tamassia, Goldwasser</em></p>

<p>We build up from \(1\) to \(k\), starting with the base case of the initial graph, which only has the initial adjacencies. We then add edges between any included nodes with path length two between them.</p>

<p>With each iteration, we introduce a new node considered in the temporary graph, and ensure that all edges within this temporary graph are transitively closed.</p>

<p>Since at the end of every step, every node is transitively closed, when all nodes are included, the entire graph is transitively closed.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Algorithm</span> <span class="nf">FloydWarshall</span><span class="o">(</span><span class="no">G</span><span class="o">)</span>
  <span class="nl">Input:</span> <span class="n">digraph</span> <span class="no">G</span>
  <span class="nl">Output:</span> <span class="n">transitive</span> <span class="n">closure</span> <span class="no">G</span><span class="o">*</span> <span class="n">of</span> <span class="no">G</span>
  <span class="n">i</span> <span class="o">&lt;-</span> <span class="mi">1</span>
  <span class="k">for</span> <span class="n">all</span> <span class="n">v</span> <span class="n">in</span> <span class="no">G</span><span class="o">.</span><span class="na">vertices</span><span class="o">()</span>
    <span class="n">denote</span> <span class="n">v</span> <span class="n">as</span> <span class="n">vi</span>
    <span class="n">i</span> <span class="o">&lt;-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="no">G_0</span> <span class="o">&lt;-</span> <span class="no">G</span>
  <span class="k">for</span> <span class="n">k</span> <span class="o">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n</span> <span class="k">do</span>
    <span class="n">G_k</span> <span class="o">&lt;-</span> <span class="no">G_</span><span class="o">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="nf">n</span><span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">k</span><span class="o">)</span> <span class="k">do</span>
      <span class="k">for</span> <span class="n">j</span> <span class="o">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="nf">n</span><span class="o">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">k</span><span class="o">)</span> <span class="k">do</span>
        <span class="k">if</span> <span class="nf">G_</span><span class="o">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">).</span><span class="na">areAdjacent</span><span class="o">(</span><span class="n">vi</span><span class="o">,</span><span class="n">vk</span><span class="o">)</span> <span class="o">&amp;</span> <span class="no">G_</span><span class="o">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">).</span><span class="na">areAdjacent</span><span class="o">(</span><span class="n">vk</span><span class="o">,</span><span class="n">vj</span><span class="o">)</span>
          <span class="k">if</span> <span class="o">!</span><span class="no">G_</span><span class="o">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">).</span><span class="na">areAdjacent</span><span class="o">(</span><span class="n">vi</span><span class="o">,</span><span class="n">vj</span><span class="o">)</span>
            <span class="n">G_k</span><span class="o">.</span><span class="na">insertDirectedEdge</span><span class="o">(</span><span class="n">vi</span><span class="o">,</span><span class="n">vj</span><span class="o">,</span><span class="n">k</span><span class="o">)</span>
  <span class="k">return</span> <span class="n">G_n</span>
</code></pre></div></div>

<h4 id="speed-analysis">Speed Analysis</h4>

<p>Running time is \(O(n^3)\) if we assume that the <code class="language-plaintext highlighter-rouge">areAdjacent</code> method takes \(O(1)\) time. We know that this depends on the implementation of the graph \(G\).</p>

<p>If, the <strong>adjacency matrix</strong> structure is used then it will be \(O(1)\) which is better than \(O(n \cdot (n+m))\) for non-sparse graphs (often graphs have many more edges than nodes).</p>

<h2 id="topological-ordering">Topological ordering</h2>

<blockquote>
  <p><strong>Theorem.</strong> A digraph has a <strong>topological ordering</strong> if it is a <strong>directed acyclic graph</strong> (DAG ‚Äì has no directed cycles). Having cycles would informally be self-dependencies</p>
</blockquote>

<p>Topological ordering means the same thing as a total relation in CS130, if the graph is considered as a set of relations.</p>

<p>To prove the theorem above, we need to prove both ways. Showing that a digraph with a topological ordering contains no directed cycles is <strong>trivial</strong>. We will employ DFS to prove the other way.</p>

<h3 id="topological-sorting-with-dfs">Topological Sorting with DFS</h3>

<blockquote>
  <p>This DFS implementation of <strong>topological sorting</strong> consists of two functions that are overloaded.</p>

  <ul>
    <li>The first function takes a graph <code class="language-plaintext highlighter-rouge">G</code> and starts labelling all vertices as <code class="language-plaintext highlighter-rouge">unexplored</code>.</li>
    <li>Then for every vertex, if the label is <code class="language-plaintext highlighter-rouge">unexplored</code> we call the <strong>second</strong> function.</li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Algorithm</span> <span class="nf">topologicalDFS</span><span class="o">(</span><span class="no">G</span><span class="o">)</span> <span class="c1">// First function</span>
  <span class="nl">Input:</span> <span class="no">DAG</span> <span class="no">G</span>
  <span class="nl">Output:</span> <span class="nc">Topological</span> <span class="n">ordering</span> <span class="n">of</span> <span class="no">G</span>
  <span class="n">n</span> <span class="o">&lt;-</span> <span class="no">G</span><span class="o">.</span><span class="na">numVertices</span><span class="o">()</span>
  <span class="k">for</span> <span class="n">all</span> <span class="n">u</span> <span class="n">in</span> <span class="no">G</span><span class="o">.</span><span class="na">vertices</span><span class="o">()</span>
    <span class="n">setLabel</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="s">"unexplored"</span><span class="o">)</span>
  <span class="k">for</span> <span class="n">all</span> <span class="n">v</span> <span class="n">in</span> <span class="no">G</span><span class="o">.</span><span class="na">vertices</span><span class="o">()</span>
    <span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="o">==</span> <span class="s">"unexplored"</span>
      <span class="n">topologicalDFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span><span class="n">v</span><span class="o">)</span>   <span class="c1">// 2nd Function</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Algorithm</span> <span class="nf">topologicalDFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span><span class="n">v</span><span class="o">)</span>
  <span class="nl">Input:</span> <span class="n">graph</span> <span class="no">G</span> <span class="n">and</span> <span class="n">a</span> <span class="n">start</span> <span class="n">vertex</span> <span class="n">v</span> <span class="n">of</span> <span class="no">G</span>
  <span class="nl">Output:</span> <span class="nc">Labelling</span> <span class="n">of</span> <span class="n">the</span> <span class="n">vertices</span> <span class="n">of</span> <span class="no">G</span> <span class="n">in</span> <span class="n">the</span> <span class="n">connected</span> <span class="n">component</span> <span class="n">of</span> <span class="n">v</span>
  <span class="nf">setLabel</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="s">"visited"</span><span class="o">)</span>
  <span class="k">for</span> <span class="n">all</span> <span class="n">e</span> <span class="n">in</span> <span class="no">G</span><span class="o">.</span><span class="na">outEdges</span><span class="o">(</span><span class="n">v</span><span class="o">)</span>
    <span class="n">w</span> <span class="o">&lt;-</span> <span class="n">opposite</span><span class="o">(</span><span class="n">v</span><span class="o">,</span><span class="n">e</span><span class="o">)</span>
    <span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">w</span><span class="o">)</span> <span class="o">==</span> <span class="s">"unexplored"</span> <span class="c1">// e is a discovery edge</span>
      <span class="n">topologicalDFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span><span class="n">w</span><span class="o">)</span>
      <span class="n">setLabel</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="s">"cross"</span><span class="o">)</span>
    <span class="c1">// else we do nothing</span>
  <span class="nc">Label</span> <span class="n">v</span> <span class="n">with</span> <span class="n">topological</span> <span class="n">number</span> <span class="n">n</span>
  <span class="n">n</span> <span class="o">&lt;-</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
</code></pre></div></div>

<p>Here we set the starting vertex <code class="language-plaintext highlighter-rouge">v</code> to <code class="language-plaintext highlighter-rouge">visited</code>, and then for all edges that originate from <code class="language-plaintext highlighter-rouge">v</code> we check if the destination vertex <code class="language-plaintext highlighter-rouge">w</code> is <code class="language-plaintext highlighter-rouge">unexplored</code>.</p>

<ul>
  <li>If so, then the edge has <strong>not been traversed</strong> before and we call the 2nd function on the vertex <code class="language-plaintext highlighter-rouge">w</code> recursively. This will continue until we arrive at a vertex \(d_n\) with <strong>no outgoing unexplored edge</strong>.
    <ul>
      <li>When this happens, we label \(d_n\) with the current number for the topological ordering (this number starts at \(n = \text{number of vertices in G}\)). Decrement n.</li>
      <li>Then as <strong>an effect</strong> of the recursive calls, the algorithm <strong>backtracks</strong> to the previous vertex \(d_x\)
        <ul>
          <li>All remaining outgoing edges of \(d_x\) are checked there will be <strong>further recursive calls</strong> to the 2nd function <strong>if possible</strong>.</li>
          <li>The next vertex with no outgoing edge \(d_{n-1}\) will be labelled with <code class="language-plaintext highlighter-rouge">n-1</code>.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>This goes on, and we will notice that after every exit from a recursive call, there will always be a <strong>unique</strong> vertex with no outgoing unexplored edge.</li>
</ul>

<p>Hence, we will be able to arrive at a topological ordering of \(G\).</p>

<p><img src="./images/toposort1.svg" class="center" /></p>

<p>You may find it beneficial to <strong>visualise</strong> the algorithm with this diagram. If you start from vertex <code class="language-plaintext highlighter-rouge">2</code> and if the loop starts from edges from <strong>bottom to top</strong> (so the first edge that the loop will process is <code class="language-plaintext highlighter-rouge">2 -&gt; 3</code>), then you will find that \(d_n\) I talk about above is <code class="language-plaintext highlighter-rouge">9</code>, \(d_x\) and \(d_{n-1}\) both refer to the same vertex <code class="language-plaintext highlighter-rouge">8</code>, and so on.</p>



                
                <footer class="site-footer">
                    
                    <span class="site-footer-owner"><a href="https://github.com/CSRG-Group/dcs-notes.github.io">dcs-notes.github.io</a> is maintained by <a href="https://github.com/CSRG-Group">CSRG-Group</a>.</span>
                    
                </footer>
            </main>
        </div>
    </div>
</body>

</html>