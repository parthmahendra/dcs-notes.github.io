<!DOCTYPE html>
<html lang=" en-US">

<head>

    
    <meta charset="UTF-8"><script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- Include tocNAV javascript -->
    <script type="text/javascript" src="/assets/js/tocNav.js"></script>

    <!-- seo used to be here -->
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="preload" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700&display=swap" as="style"
        type="text/css" crossorigin>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="/assets/css/style.css">
    <title>CS126 General Algorithms</title>
</head>

<body>
    <div id="mainGrid" class="container">
        <header style="padding:10px;" class="page-header notes-header" role="banner">
            <h1 class="project-name">General Algorithms</h1>
        </header>
        <div title="Table of Contents" class="buttonCol" onclick="toggleNav()">
            <div class="navArrow">
                <i></i>
            </div>
        </div>
        <div class="navBox">
            <div id="sidenav" class="sideNav closedNav">
                <h2 style="margin-left: 10px;">Table of Contents</h2><ul class="table-of-contents"><li><a href="#searching-data-structures">Searching data structures</a><ul><li><a href="#linear-search">Linear search</a></li><li><a href="#binary-search">Binary search</a><ul><li><a href="#iterative-algorithm">Iterative algorithm</a></li><li><a href="#recursive-algorithm">Recursive algorithm</a></li></ul></li></ul></li><li><a href="#sorting-data-structures">Sorting data structures</a><ul><li><a href="#insertion-sort">Insertion sort</a></li><li><a href="#selection-sort">Selection sort</a></li><li><a href="#heap-sort">Heap sort</a></li><li><a href="#merge-sort">Merge sort</a></li></ul></li><li><a href="#reversing-data-structures">Reversing data structures</a><ul><li><a href="#reversing-a-stack">Reversing a stack</a></li><li><a href="#reversing-a-linked-list">Reversing a linked list</a></li></ul></li><li><a href="#set-operations">Set operations</a><ul><li><a href="#generic-merging">Generic merging</a></li></ul></li><li><a href="#graph-algorithms">Graph algorithms</a><ul><li><a href="#depth-first-search">Depth-first search</a><ul><li><a href="#dfs-for-an-entire-graph">DFS for an entire graph:</a></li><li><a href="#path-finding-with-dfs">Path Finding with DFS</a></li><li><a href="#cycle-finding-with-dfs">Cycle Finding with DFS</a></li><li><a href="#topological-ordering-using-dfs">Topological ordering using DFS</a></li></ul></li><li><a href="#breadth-first-search">Breadth-first search</a></li><li><a href="#directed-graphs">Directed graphs</a></li></ul></li><li><a href="#miscellaneous">Miscellaneous</a><ul><li><a href="#computing-spans">Computing spans</a></li><li><a href="#fibonacci">Fibonacci</a><ul><li><a href="#exponential-time">Exponential time</a></li><li><a href="#linear-time">Linear time</a></li></ul></li></ul></li></ul>
</div>
        </div>
        
        <div class="contents">
            <main id="content" class="main-content" role="main">
                <div class="partNav"><a href="/CS126/digraphs.html" title="Directed Graphs">üëàPrev</a><a href="./" title="CS126 Home">üè°CS126</a></div>
                <!-- Main Content of markdown or sub-layouts-->
                <!-- Each module has its own layout to allow module layouts to be customised -->
<!-- The layout name is also used by the notes layout to display the correct module code -->

<h1 id="searching-data-structures">Searching data structures</h1>

<h2 id="linear-search">Linear search</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Let arr &lt;- the array to search
Let k &lt;- the item to search for
Let n &lt;- 0

While n is smaller than the length of arr
	If k is equal to arr[n]
		Stop, since the item is found
	Increment n
Stop, since the item is not in the array
</code></pre></div></div>

<h2 id="binary-search">Binary search</h2>

<p>This binary search algorithm is used for searching an array, and will return the index of the item in the array else -1.</p>

<pre><code class="language-{java}">Let arr &lt;- the array to search
Let k &lt;- the iterm to search for
if !(arr.isSorted())
	arr.mergeSort()
binarySearch(arr, k, int lowerBound, upperBound)
	middle &lt;- (lowerBound + upperBound) / 2
	if upperBound &lt; lowerBound
		return - 1
	if k == arr[middle]
    		return middle
	else if k &lt; arr[middle]
    		return binarySearch(arr, k, lowerBound, middle -1)
    	else 
        	return binarySearch(arr, k, middle + 1, upperBound)
      
</code></pre>

<h3 id="iterative-algorithm">Iterative algorithm</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Let arr &lt;- the array to search
Let k &lt;- the item to search for
Let l &lt;- 0
Let r &lt;- the size of arr - 1
Let m &lt;- (l+r) / 2

While l != r
	If k is equal to arr[n]
		Stop, since the item is found
	Else if k is less than arr[n]
		r &lt;- m - 1
		m &lt;- (l+r) / 2
	Else (if k is greater than arr[n])
		l &lt;- m
		m &lt;- (l+r) / 2
Stop, since the item is not in the array
</code></pre></div></div>

<h3 id="recursive-algorithm">Recursive algorithm</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Let arr &lt;- the array to search
Let k &lt;- the item to search for

Function binarySearch(arr, k)
	Let l &lt;- 0
    Let r &lt;- the size of arr - 1
    Let m &lt;- (l+r) / 2
    If l == m
    	Stop, since the item is not in the array
    Else if k is equal to arr[n]
		Stop, since the item is found
	Else if k is less than arr[n]
		binarySearch(arr[l:m], k)
	Else (if k is greater than arr[n])
		binarySearch(arr[m:r], k)
</code></pre></div></div>

<h1 id="sorting-data-structures">Sorting data structures</h1>

<h2 id="insertion-sort">Insertion sort</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Let P &lt;- a priority queue using an sorted array implementation
Let arr &lt;- the array to sort
Let arr' &lt;- the sorted array
For each i in arr
	Enqueue i to P
While P is not empty
	Let i &lt;- Dequeue from P
	Append i to arr'
</code></pre></div></div>

<h2 id="selection-sort">Selection sort</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Let P &lt;- a priority queue using an unsorted array implementation
Let arr &lt;- the array to sort
Let arr' &lt;- the sorted array
For each i in arr
	Enqueue i to P
While P is not empty
	Let i &lt;- Dequeue from P
	Append i to arr'
</code></pre></div></div>

<h2 id="heap-sort">Heap sort</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Let P &lt;- a priority queue using a heap based implementation
Let arr &lt;- the array to sort
Let arr' &lt;- the sorted array
For each i in arr
	Enqueue i to P
While P is not empty
	Let i &lt;- Dequeue from P
	Append i to arr'
</code></pre></div></div>

<h2 id="merge-sort">Merge sort</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Let arr &lt;- the array to sort

Function mergeSort(arr)
	If arr contains only one element
		Return arr
    Let lArr, rArr &lt;- arr split into two even halves
    Return merge(
    	mergeSort(lArr),
    	mergeSort(rArr)
    )
    
Function merge(arr1, arr2)
	Let arr' &lt;- an empty array large enough to fit both arr1 and arr2 in
	Let n1, n2 &lt;- 0
	While neither arr1 nor arr2 are empty
		If arr1[n1] = arr2[n2]
			Append arr1[n1] and arr2[n2] to arr'
			Increment n1 and n2
		Else if arr1[n1] &lt; arr2[n2]
			Append arr1[n1] to arr'
			Increment n1
		Else (if arr1[n1] &gt; arr2[n2])
			Append arr2[n2] to arr'
			Increment n2
	For each element in arr1 from n1 to its last element
		Append arr1[n1] to arr'
	For each element in arr2 from n2 to its last element
		Append arr2[n2] to arr'
	Return arr'
</code></pre></div></div>

<h1 id="reversing-data-structures">Reversing data structures</h1>
<h2 id="reversing-a-stack">Reversing a stack</h2>

<p>Push all the items in array to the stack, then pop all the items off the stack into the new reversed array</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Let S &lt;- the stack to reverse
Let S' &lt;- an empty stack (the output)
For each item in S
	Pop the head off S into s
	Push s to the head of S'
</code></pre></div></div>

<h2 id="reversing-a-linked-list">Reversing a linked list</h2>

<p>Iterate over the linked list from the head, and for each element in the list to reverse, set the item as the predecessor of the head in the new reversed list</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Let L &lt;- the linked list to reverse
Let L' &lt;- an empty linked list (the output)
For each item in S
	Let l &lt;- the first item in the linked list
	Delete the first item in the linked list
	Add l as the head of L'
</code></pre></div></div>

<h1 id="set-operations">Set operations</h1>

<h2 id="generic-merging">Generic merging</h2>

<p>Taking the union of two sets, in linear time:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Let A, B &lt;- The lists to merge
Let S &lt;- an empty list (the output)
While neither A nor B are empty
	Let a, b &lt;- The first elements of A and B respectively
	If a &lt; b
		Add a to the end of S
		Remove a from A
	Else if b &lt; a
		Add b to the end of S
		Remove b from B
	Else (hence a=b)
		Add a to the end of S (both are equal, so it doesn't matter which)
		Remove a and b from A and B respectively
(Cleaning up the other list when one is empty)
While A is not empty
	Add all the items left in A to the end of S
While B is not empty
	Add all the items left in B to the end of S
</code></pre></div></div>

<h1 id="graph-algorithms">Graph algorithms</h1>

<h2 id="depth-first-search">Depth-first search</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">DFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span>
	<span class="n">setLabel</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="no">VISITED</span><span class="o">)</span>
	<span class="k">for</span> <span class="nf">each</span> <span class="o">(</span><span class="nc">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="no">G</span><span class="o">.</span><span class="na">incidentEdges</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
        	<span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="o">=</span> <span class="no">UNEXPLORED</span>
			<span class="n">w</span> <span class="o">=</span> <span class="n">opposite</span><span class="o">(</span><span class="n">v</span><span class="o">,</span><span class="n">e</span><span class="o">)</span>  	
            		<span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">w</span><span class="o">)</span> <span class="o">=</span> <span class="no">UNEXPLORED</span>
                		<span class="nf">setLabel</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="no">DISCOVERY</span><span class="o">)</span>
                		<span class="no">DFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span><span class="n">w</span><span class="o">)</span>
            		<span class="k">else</span> 
               			<span class="nf">setLabel</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="no">BACK</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="dfs-for-an-entire-graph">DFS for an entire graph:</h3>

<p>The following algorithm is pseudocode for Depth First Search - as displayed by the CS126 lectures, which is used to perform depth first search on the entire graph.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// For the entire graph</span>
<span class="no">DFS</span><span class="o">(</span><span class="no">G</span><span class="o">)</span>
    	<span class="k">for</span> <span class="nf">each</span> <span class="o">(</span><span class="nc">Vertex</span> <span class="n">u</span> <span class="o">:</span> <span class="no">G</span><span class="o">.</span><span class="na">vertices</span><span class="o">())</span>
        	<span class="n">setLabel</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="no">UNEXPLORED</span><span class="o">)</span>
    	<span class="k">for</span> <span class="nf">each</span> <span class="o">(</span><span class="nc">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="no">G</span><span class="o">.</span><span class="na">edges</span><span class="o">())</span>
        	<span class="n">setLabel</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="no">UNEXPLORED</span><span class="o">)</span>
    	<span class="k">for</span> <span class="nf">each</span> <span class="o">(</span><span class="nc">Vertex</span> <span class="n">u</span> <span class="o">:</span> <span class="no">G</span><span class="o">.</span><span class="na">vertices</span><span class="o">())</span>
        	<span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="no">UNEXPLORED</span><span class="o">)</span>
            		<span class="no">DFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span> <span class="n">u</span><span class="o">)</span>
            
<span class="c1">// For each vertex individually      </span>
<span class="no">DFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span>
	<span class="n">setLabel</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="no">VISITED</span><span class="o">)</span>
	<span class="k">for</span> <span class="nf">each</span> <span class="o">(</span><span class="nc">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="no">G</span><span class="o">.</span><span class="na">incidentEdges</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
        	<span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="o">=</span> <span class="no">UNEXPLORED</span>
			<span class="n">w</span> <span class="o">=</span> <span class="n">opposite</span><span class="o">(</span><span class="n">v</span><span class="o">,</span><span class="n">e</span><span class="o">)</span>  	
            		<span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">w</span><span class="o">)</span> <span class="o">=</span> <span class="no">UNEXPLORED</span>
                		<span class="nf">setLabel</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="no">DISCOVERY</span><span class="o">)</span>
                		<span class="no">DFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span><span class="n">w</span><span class="o">)</span>
            		<span class="k">else</span> 
               			<span class="nf">setLabel</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="no">BACK</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="path-finding-with-dfs">Path Finding with DFS</h3>

<p>By using an alteration of the depth first search algorithm, we can use it to find a path between two given vertices, using the <strong>template method pattern</strong>
where <strong>S</strong> is an initially empty stack</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pathDFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span>
    	<span class="n">setLabel</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="no">VISITED</span><span class="o">)</span>
   	<span class="no">S</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">v</span><span class="o">)</span>
    	<span class="k">if</span> <span class="n">v</span> <span class="o">=</span> <span class="n">z</span>
        	<span class="k">return</span> <span class="no">S</span><span class="o">.</span><span class="na">elements</span><span class="o">()</span>
    	<span class="k">for</span> <span class="nf">each</span> <span class="o">(</span><span class="nc">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="no">G</span><span class="o">.</span><span class="na">incidentEdges</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
        	<span class="k">if</span> <span class="nf">getLbel</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="o">=</span> <span class="no">UNEXPLORED</span>
            		<span class="n">w</span> <span class="o">=</span> <span class="n">opposite</span><span class="o">(</span><span class="n">v</span><span class="o">,</span><span class="n">e</span><span class="o">)</span>
            		<span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">w</span><span class="o">)</span> <span class="o">=</span> <span class="no">UNEXPLORED</span>
                		<span class="nf">setLabel</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="no">DISCOVERY</span><span class="o">)</span>
                		<span class="no">S</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>
                		<span class="n">pathDFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span><span class="n">w</span><span class="o">,</span><span class="n">z</span><span class="o">)</span>
                		<span class="no">S</span><span class="o">.</span><span class="na">pop</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>
           		<span class="k">else</span> 
                		<span class="nf">setLabel</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="no">BACK</span><span class="o">)</span>
		<span class="no">S</span><span class="o">.</span><span class="na">pop</span><span class="o">(</span><span class="n">v</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="cycle-finding-with-dfs">Cycle Finding with DFS</h3>

<p>The algorithm for DFS can be adapted slightly in order to find a simply cycle back to the start node.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cycleDFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span>
   	<span class="n">setLabel</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="no">VISITED</span><span class="o">)</span>
    	<span class="no">S</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">v</span><span class="o">)</span>
    	<span class="k">for</span> <span class="nf">each</span> <span class="o">(</span><span class="nc">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="no">G</span><span class="o">.</span><span class="na">incidentEdges</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
        	<span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="o">=</span> <span class="no">UNEXPLORED</span>
            		<span class="n">w</span> <span class="o">=</span> <span class="n">opposite</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>
            		<span class="no">S</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>
            		<span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">w</span><span class="o">)</span> <span class="o">=</span> <span class="no">UNEXPLORED</span>
                		<span class="nf">setLabel</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="no">DISCOVERY</span><span class="o">)</span>
                		<span class="n">cycleDFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span>
               			<span class="no">S</span><span class="o">.</span><span class="na">pop</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>
           		 <span class="k">else</span> 
               			<span class="no">T</span> <span class="o">=</span> <span class="k">new</span> <span class="n">empty</span> <span class="nc">Stack</span>
                		<span class="n">repeat</span>
                			<span class="n">o</span> <span class="o">=</span> <span class="no">S</span><span class="o">.</span><span class="na">pop</span>
                			<span class="no">T</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">o</span><span class="o">)</span>
                		<span class="n">until</span> <span class="n">o</span> <span class="o">=</span> <span class="n">w</span>
                		<span class="k">return</span> <span class="no">T</span><span class="o">.</span><span class="na">elements</span><span class="o">()</span>
	<span class="no">S</span><span class="o">.</span><span class="na">pop</span><span class="o">(</span><span class="n">v</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="topological-ordering-using-dfs">Topological ordering using DFS</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">topologicalDFS</span><span class="o">(</span><span class="no">G</span><span class="o">)</span>
    	<span class="n">z</span> <span class="o">=</span> <span class="no">G</span><span class="o">.</span><span class="na">getVertices</span><span class="o">()</span>
    	<span class="k">for</span> <span class="nf">each</span> <span class="o">(</span><span class="nc">Vertex</span> <span class="n">u</span> <span class="o">:</span> <span class="no">G</span><span class="o">.</span><span class="na">vertices</span><span class="o">)</span>
        	<span class="n">setLabel</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="no">UNEXPLORED</span><span class="o">)</span>
    	<span class="k">for</span> <span class="nf">each</span> <span class="o">(</span><span class="nc">Vertex</span> <span class="n">v</span> <span class="o">:</span> <span class="no">G</span><span class="o">.</span><span class="na">vertices</span><span class="o">)</span>
        	<span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="o">=</span> <span class="no">UNEXPLORED</span>
            		<span class="nf">topologicalDFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span>


<span class="n">topologicalDFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span>
	<span class="n">setLabel</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="no">VISITED</span><span class="o">)</span>
    	<span class="k">for</span> <span class="nf">each</span> <span class="o">(</span><span class="nc">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">outgoingEdges</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
        	<span class="n">w</span> <span class="o">=</span> <span class="n">opposite</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>
        	<span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">w</span><span class="o">)</span> <span class="o">=</span> <span class="no">UNEXPLORED</span>	
            		<span class="nf">topologicalDFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span>
        	<span class="k">else</span>
            		<span class="nc">Label</span> <span class="n">v</span> <span class="n">with</span> <span class="n">topological</span> <span class="n">number</span> <span class="n">n</span>
        	<span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
</code></pre></div></div>

<h2 id="breadth-first-search">Breadth-first search</h2>

<blockquote>
  <p><strong>Algorithm</strong> \(BFS(G, s)\)
		\(L_0 \leftarrow\) new empty sequence
		\(L_0 .addLast(s)\)
		\(setLabel(s, VISITED)\)
		\(i \leftarrow 0\)
		<strong>while</strong> \(¬¨L_i .isEmpty()\)
		    \(L_i+1 \leftarrow\) new empty sequence
		    <strong>for all</strong> \(v\in L_i .elements()\)
		 		   <strong>for all</strong> \(e \in G.incidentEdges(v)\)
		 		 		  <strong>if</strong> \(getLabel(e) = UNEXPLORED\)
		 		 		 		 \(w \leftarrow opposite(v,e)\)
		 		 		 		 <strong>if</strong> \(getLabel(w) = UNEXPLORED\)
		 		 		 		 		\(setLabel(e) = (e, DISCOVERY)\)
		 		 		 		 		\(setLabel(w,VISITED)\)
		 		 		 		 		\(L_i+1 .addLast(w)\)
		 		 		 		 <strong>else</strong>
		 		 		 		 		\(setLabel(e,CROSS)\)
		    \(i \leftarrow i + 1\)
<strong>END ALGORITHM</strong></p>
</blockquote>

<h2 id="directed-graphs">Directed graphs</h2>

<blockquote>
  <p><strong>Algorithm</strong> \(FloydWarshall(G)\)
		<strong>Input</strong> digraph \(G\)
		<strong>Output</strong> transitive closure \(G^*\) of \(G\)
		\(i \leftarrow 1\)
		<strong>for all</strong> \(v \in G.vertices()\)
		    denote \(v\) as \(v_i\)
		    \(i \leftarrow i + 1\)
		\(G_0 \leftarrow G\)
		<strong>for</strong> \(k \leftarrow 1\) <strong>to</strong> \(n\) <strong>do</strong>
		    \(G_k \leftarrow G_{k-1}\)
		 		   <strong>for</strong> \(i\leftarrow 1\) <strong>to</strong> \(n(i\neq k)\) <strong>do</strong>
		 		 		  <strong>for</strong> \(j \leftarrow 1\) <strong>to</strong> \(n(j\neq i, k)\) <strong>do</strong>
		 		 		 		 <strong>if</strong> \(G_{k-1}.areAdjacent(v_i,v_k)\)  \(\&amp;\) \(G_{k-1}.areAdjacent(v_k,v_j)\)
		 		 		 		 		<strong>if</strong> \(¬¨G_{k-1}.areAdjacent(v_i,v_j)\)
		 		 		 		 		    \(G_k.insertDirectedEdge(v_i,v_j,k)\)
		    <strong>return</strong> \(G_n\)
**END ALGORITHM</p>
</blockquote>

<h1 id="miscellaneous">Miscellaneous</h1>

<h2 id="computing-spans">Computing spans</h2>

<p>The span of an array is the maximum number of consecutive elements less than a value at an index which precede it
This can be calculated in linear time by</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Let X &lt;- the array to find spans of
Let S &lt;- a stack of all the indices in X
Let i be the current index
Pop indices from the stack until we find index j such that X[i] &lt; X[j]
Set S[i] &lt;- i-j
Push i to the stack
</code></pre></div></div>

<h2 id="fibonacci">Fibonacci</h2>

<h3 id="exponential-time">Exponential time</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Function fibonacci(k)
	If k = 1
		Return k
	Else
		Return fibonacci(k-1) + fibonacci(k-2)
</code></pre></div></div>

<p>This is very inefficient, running in \(O(2^n)\) time, since it re-calculates calls to <code class="language-plaintext highlighter-rouge">fibonacci(k)</code> for some <code class="language-plaintext highlighter-rouge">k</code> many times, instead of using the same result every time it is needed</p>

<h3 id="linear-time">Linear time</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//Returns the tuple (f_k, f_k-1)
Function fibonacci(k)
	If k = 1
		Return (k, 0)
	Else
		Let i,j &lt;- fibonacci(k - 1)
		Return (i-j, i)
</code></pre></div></div>


                
                <footer class="site-footer">
                    
                    <span class="site-footer-owner"><a href="https://github.com/CSRG-Group/dcs-notes.github.io">dcs-notes.github.io</a> is maintained by <a href="https://github.com/CSRG-Group">CSRG-Group</a>.</span>
                    
                </footer>
            </main>
        </div>
    </div>
</body>

</html>